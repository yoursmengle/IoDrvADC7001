 /**
 * <interfacename>CmpNameServiceServer</interfacename>
 * <description> 
 *	External interface for the naming service server
 * </description>
 *
 * <copyright>(c) 2003-2017 3S-Smart Software Solutions</copyright>
 */


	
	
#ifndef _CMPNAMESERVICESERVERITF_H_
#define _CMPNAMESERVICESERVERITF_H_

#include "CmpStd.h"

 

 




#include "CmpNameService.h"

#ifdef __cplusplus
	extern "C" {
#endif

/**
 * <category>Event parameter</category>
 * <element name="ui8OemDataLen" type="INOUT">IN: Maximum length that can be written. OUT: Length needed / written by OEM.</element>
 * <element name="pData" type="IN">Buffer where to write the OEM data.</element>
 */
typedef struct
{
	RTS_UI8 ui8OemDataLen;
	char *pData;
} EVTPARAM_CmpNSSOemCallback;
#define EVTPARAMID_CmpNSSOemCallback						0x0001
#define EVTVERSION_CmpNSSOemCallback						0x0001

/**
 * <category>Events</category>
 * <description>Event is sent when a the NameServiceServer retrieves the information put into the OEM field of the naming response.
 * Note: The information put here are not evaluted by the default Automation Platform. A OEM plug in is needed to handle this data in the Automation Platform.
 * Note: The event is sent twice. The first time pData is NULL and ui8OemDataLen is 0. This is used to get the needed length of the OEM data.The OEM should 
 *       fill up the needed length into the ui8OemDataLen. 
 *       The second time the pData is available an can be filled up. ui8OemDataLen should be filled up with the actual written length.
 * </description>
 * <param name="pEventParam" type="IN">EVTPARAMID_CmpNSSOem</param>
 */
#define EVT_CmpNSSOemCallback					MAKE_EVENTID(EVTCLASS_NONE, 1)

/* -- Functions exported to the Router component */

/** <description> Protocol handler of CmpNameServiceServer. 
*   Attention: Must only be called by CmpRouter to forward an incoming data package.</description>
* <param name="hRouter" type="IN">Handle of router instance calling this function.
*   For L4 client implementations, by default it is called by the router instance 0.
*   For L4 server implementations, it is called by the router instance which has received the package originally.</param>
* <param name="hNetworkInterface" type="IN">Handle of the network interface receiving originally the package</param>
* <param name="byServiceId" type="IN">The protocol id of the package</param>
* <param name="byMessageId" type="IN">The message id of the package</param>
* <param name="addrSender"	type="IN"> Sender address.
*   The pointer within will not be valid after this function returns.</param>
* <param name="addrReceiver" type="IN">
*   Receiver address (either the address of this node or a broadcast address). 
*   The pointer within will not be valid after this function returns.</param>
* <param name="pduData" type="IN">
*   The received data. The data pointer will not be valid after this function returns.</param>
* <param name="nRouterError" type="IN">
*   If this value is not ERR_OK, then this message has been generated by an intermediate node in response to a
*   message previously sent by this node, that could not be delivered.
*   nRouterError identifies the kind of error that happened.
*   pduData then contains a detailed error description depending on the kind of error.
* </param>
* <result>error code</result>
*/
RTS_RESULT CDECL NSServerHandleData(RTS_HANDLE hRouter, RTS_HANDLE hNetworkInterface, RTS_UI8 byServiceId, RTS_UI8 byMessageId, PEERADDRESS addrSender, PEERADDRESS addrReceiver, PROTOCOL_DATA_UNIT pduData, RTS_RESULT nRouterError);
typedef RTS_RESULT (CDECL * PFNSSERVERHANDLEDATA) (RTS_HANDLE hRouter, RTS_HANDLE hNetworkInterface, RTS_UI8 byServiceId, RTS_UI8 byMessageId, PEERADDRESS addrSender, PEERADDRESS addrReceiver, PROTOCOL_DATA_UNIT pduData, RTS_RESULT nRouterError);
#if defined(CMPNAMESERVICESERVER_NOTIMPLEMENTED) || defined(NSSERVERHANDLEDATA_NOTIMPLEMENTED)
	#define USE_NSServerHandleData
	#define EXT_NSServerHandleData
	#define GET_NSServerHandleData(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSServerHandleData(p0,p1,p2,p3,p4,p5,p6,p7)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSServerHandleData  FALSE
	#define EXP_NSServerHandleData  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSServerHandleData
	#define EXT_NSServerHandleData
	#define GET_NSServerHandleData(fl)  CAL_CMGETAPI( "NSServerHandleData" ) 
	#define CAL_NSServerHandleData  NSServerHandleData
	#define CHK_NSServerHandleData  TRUE
	#define EXP_NSServerHandleData  CAL_CMEXPAPI( "NSServerHandleData" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICESERVER_EXTERNAL)
	#define USE_NSServerHandleData
	#define EXT_NSServerHandleData
	#define GET_NSServerHandleData(fl)  CAL_CMGETAPI( "NSServerHandleData" ) 
	#define CAL_NSServerHandleData  NSServerHandleData
	#define CHK_NSServerHandleData  TRUE
	#define EXP_NSServerHandleData  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSServerHandleData", (RTS_UINTPTR)NSServerHandleData, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceServerNSServerHandleData
	#define EXT_CmpNameServiceServerNSServerHandleData
	#define GET_CmpNameServiceServerNSServerHandleData  ERR_OK
	#define CAL_CmpNameServiceServerNSServerHandleData pICmpNameServiceServer->INSServerHandleData
	#define CHK_CmpNameServiceServerNSServerHandleData (pICmpNameServiceServer != NULL)
	#define EXP_CmpNameServiceServerNSServerHandleData  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSServerHandleData
	#define EXT_NSServerHandleData
	#define GET_NSServerHandleData(fl)  CAL_CMGETAPI( "NSServerHandleData" ) 
	#define CAL_NSServerHandleData pICmpNameServiceServer->INSServerHandleData
	#define CHK_NSServerHandleData (pICmpNameServiceServer != NULL)
	#define EXP_NSServerHandleData  CAL_CMEXPAPI( "NSServerHandleData" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSServerHandleData  PFNSSERVERHANDLEDATA pfNSServerHandleData;
	#define EXT_NSServerHandleData  extern PFNSSERVERHANDLEDATA pfNSServerHandleData;
	#define GET_NSServerHandleData(fl)  s_pfCMGetAPI2( "NSServerHandleData", (RTS_VOID_FCTPTR *)&pfNSServerHandleData, (fl), 0, 0)
	#define CAL_NSServerHandleData  pfNSServerHandleData
	#define CHK_NSServerHandleData  (pfNSServerHandleData != NULL)
	#define EXP_NSServerHandleData  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSServerHandleData", (RTS_UINTPTR)NSServerHandleData, 0, 0) 
#endif




#ifdef __cplusplus
}
#endif




typedef struct
{
	IBase_C *pBase;
	PFNSSERVERHANDLEDATA INSServerHandleData;
 } ICmpNameServiceServer_C;

#ifdef CPLUSPLUS
class ICmpNameServiceServer : public IBase
{
	public:
		virtual RTS_RESULT CDECL INSServerHandleData(RTS_HANDLE hRouter, RTS_HANDLE hNetworkInterface, RTS_UI8 byServiceId, RTS_UI8 byMessageId, PEERADDRESS addrSender, PEERADDRESS addrReceiver, PROTOCOL_DATA_UNIT pduData, RTS_RESULT nRouterError) =0;
};
	#ifndef ITF_CmpNameServiceServer
		#define ITF_CmpNameServiceServer static ICmpNameServiceServer *pICmpNameServiceServer = NULL;
	#endif
	#define EXTITF_CmpNameServiceServer
#else	/*CPLUSPLUS*/
	typedef ICmpNameServiceServer_C		ICmpNameServiceServer;
	#ifndef ITF_CmpNameServiceServer
		#define ITF_CmpNameServiceServer
	#endif
	#define EXTITF_CmpNameServiceServer
#endif

#ifdef CPLUSPLUS_ONLY
  #undef CPLUSPLUS_ONLY
#endif

#endif /*_CMPNAMESERVICESERVERITF_H_*/
