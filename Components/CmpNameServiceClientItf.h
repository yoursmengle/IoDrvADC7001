 /**
 * <interfacename>CmpNameServiceClient</interfacename>
 * <description> 
 *	External interface for the naming service client
 * </description>
 *
 * <copyright>(c) 2003-2017 3S-Smart Software Solutions</copyright>
 */


	
	
#ifndef _CMPNAMESERVICECLIENTITF_H_
#define _CMPNAMESERVICECLIENTITF_H_

#include "CmpStd.h"

 

 




#include "CmpNameService.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * <category>Settings</category>
 * <type>Int</type>
 * <description>
 *	Timeout in seconds after the CmpChannelClient (Gateway) signals the end of the network scan to the client. 
 *  All further incomming network scan answers for this scan request will be dropped. 
 *  ATTENTION: This timeout should only be adapted, if there are nodes connected to the PLC network, which 
 *  need more than around 6 seconds to handle the scan request and return the answer. The only known reason 
 *  is, that the scan have to be forwarded into another network (non-3S-protocol).
 *  If this timeout must be adapted, you have to check all used clients (CoDeSys, OPC-Server, PLCHandler,
 *  DataServer, ...) if the network scan and finding the nodes still works in a proper way.       
 * </description>
 */
#define NAMESERVICESRVKEY_INT_SCAN_TIME								"ScanTimeSeconds"
#define NAMESERVICESRVVALUE_INT_SCAN_TIME_DEFAULT					10


 /* -- Functions exported to the Router component */

 /** <description> Protocol handler of CmpNameServiceClient.
 *   Attention: Must only be called by CmpRouter to forward an incoming data package.</description>
 * <param name="hRouter" type="IN">Handle of router instance calling this function.
 *   For L4 client implementations, by default it is called by the router instance 0.
 *   For L4 server implementations, it is called by the router instance which has received the package originally.</param>
 * <param name="hNetworkInterface" type="IN">Handle of the network interface receiving originally the package</param>
 * <param name="byServiceId" type="IN">The protocol id of the package</param>
 * <param name="byMessageId" type="IN">The message id of the package</param>
 * <param name="addrSender"	type="IN"> Sender address.
 *   The pointer within will not be valid after this function returns.</param>
 * <param name="addrReceiver" type="IN">
 *   Receiver address (either the address of this node or a broadcast address).
 *   The pointer within will not be valid after this function returns.</param>
 * <param name="pduData" type="IN">
 *   The received data. The data pointer will not be valid after this function returns.</param>
 * <param name="nRouterError" type="IN">
 *   If this value is not ERR_OK, then this message has been generated by an intermediate node in response to a
 *   message previously sent by this node, that could not be delivered.
 *   nRouterError identifies the kind of error that happened.
 *   pduData then contains a detailed error description depending on the kind of error.
 * </param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSClientHandleData(RTS_HANDLE hRouter, RTS_HANDLE hNetworkInterface, RTS_UI8 byServiceId, RTS_UI8 byMessageId, PEERADDRESS addrSender, PEERADDRESS addrReceiver, PROTOCOL_DATA_UNIT pduData, RTS_RESULT nRouterError);
typedef RTS_RESULT (CDECL * PFNSCLIENTHANDLEDATA) (RTS_HANDLE hRouter, RTS_HANDLE hNetworkInterface, RTS_UI8 byServiceId, RTS_UI8 byMessageId, PEERADDRESS addrSender, PEERADDRESS addrReceiver, PROTOCOL_DATA_UNIT pduData, RTS_RESULT nRouterError);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSCLIENTHANDLEDATA_NOTIMPLEMENTED)
	#define USE_NSClientHandleData
	#define EXT_NSClientHandleData
	#define GET_NSClientHandleData(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSClientHandleData(p0,p1,p2,p3,p4,p5,p6,p7)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSClientHandleData  FALSE
	#define EXP_NSClientHandleData  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSClientHandleData
	#define EXT_NSClientHandleData
	#define GET_NSClientHandleData(fl)  CAL_CMGETAPI( "NSClientHandleData" ) 
	#define CAL_NSClientHandleData  NSClientHandleData
	#define CHK_NSClientHandleData  TRUE
	#define EXP_NSClientHandleData  CAL_CMEXPAPI( "NSClientHandleData" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSClientHandleData
	#define EXT_NSClientHandleData
	#define GET_NSClientHandleData(fl)  CAL_CMGETAPI( "NSClientHandleData" ) 
	#define CAL_NSClientHandleData  NSClientHandleData
	#define CHK_NSClientHandleData  TRUE
	#define EXP_NSClientHandleData  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSClientHandleData", (RTS_UINTPTR)NSClientHandleData, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSClientHandleData
	#define EXT_CmpNameServiceClientNSClientHandleData
	#define GET_CmpNameServiceClientNSClientHandleData  ERR_OK
	#define CAL_CmpNameServiceClientNSClientHandleData pICmpNameServiceClient->INSClientHandleData
	#define CHK_CmpNameServiceClientNSClientHandleData (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSClientHandleData  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSClientHandleData
	#define EXT_NSClientHandleData
	#define GET_NSClientHandleData(fl)  CAL_CMGETAPI( "NSClientHandleData" ) 
	#define CAL_NSClientHandleData pICmpNameServiceClient->INSClientHandleData
	#define CHK_NSClientHandleData (pICmpNameServiceClient != NULL)
	#define EXP_NSClientHandleData  CAL_CMEXPAPI( "NSClientHandleData" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSClientHandleData  PFNSCLIENTHANDLEDATA pfNSClientHandleData;
	#define EXT_NSClientHandleData  extern PFNSCLIENTHANDLEDATA pfNSClientHandleData;
	#define GET_NSClientHandleData(fl)  s_pfCMGetAPI2( "NSClientHandleData", (RTS_VOID_FCTPTR *)&pfNSClientHandleData, (fl), 0, 0)
	#define CAL_NSClientHandleData  pfNSClientHandleData
	#define CHK_NSClientHandleData  (pfNSClientHandleData != NULL)
	#define EXP_NSClientHandleData  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSClientHandleData", (RTS_UINTPTR)NSClientHandleData, 0, 0) 
#endif





/* -- Functions exported to the client */

/**
 * <description>
 *  A callback passed to the nameservice functions, that is called for each found node, on error or completion.
 *  This version can return all fields of name service answer version V1.1 (NSVERSION_FIRST_IMPLEMENTATION).
 * <param name="nResult" type="IN">The result of the call. Might be ERR_OK or ERR_TIMEOUT.</param>
 * <param name="addrNode" type="IN">The address of the responding node.</param>
 * <param name="pNodeInfo" type="IN">Only valid if nResult==ERR_OK and until callback returns.</param>
 * <param name="wVersion" type="IN">Version of the received name service package.</param>
 * <param name="dwRequestID" type="IN">The same value that was passed in to the request.</param>
 * <param name="bComplete" type="IN">Is true, if this was the last answer to the request.</param>
 * <result></result>
 */
typedef void (CDECL *PFHANDLENSRESPONSE) (RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED *pNodeInfo, unsigned short wVersion, RTS_HANDLE dwRequestId, int bComplete);

/**
 * <description>
 *	A callback passed to the nameservice functions, that is called for each found node, on error or completion.
 *  This version can return all fields of name service answer versions <= V1.3 (NSVERSION_WITH_ADDRDIFFERENCE).
 * </description>
 * <param name="nResult" type="IN">The result of the call. Might be ERR_OK or ERR_TIMEOUT.</param>
 * <param name="addrNode" type="IN">The address of the responding node.</param>
 * <param name="pNodeInfo2" type="IN">Only valid if nResult==ERR_OK and until callback returns.</param>
 * <param name="wVersion" type="IN">Version of the received name service package.</param>
 * <param name="dwRequestID" type="IN">The same value that was passed in to the request.</param>
 * <param name="bComplete" type="IN">Is true, if this was the last answer to the request.</param>
 * <result></result>
 */
typedef void (CDECL *PFHANDLENSRESPONSE2) (RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED2 *pNodeInfo2, unsigned short wVersion, RTS_HANDLE dwRequestId, int bComplete);

/**
 * <description>
 *  A callback passed to the nameservice functions, that is called on for each found node, on error or completion.
 *  This version can return all fields of all name service answer versions. 
 *  Note: For online received name service answers < V4.0, the length of the returned node name, device name and vendor name
 *  may exceed the limits defined for NODEINFOPACKED3.   
 * </description>
 * <param name="nResult" type="IN">The result of the call. Might be ERR_OK or ERR_TIMEOUT.</param>
 * <param name="addrNode" type="IN">The address of the responding node.</param>
 * <param name="pNodeInfo3" type="IN">Only valid if nResult==ERR_OK and until callback returns.</param>
 * <param name="wVersion" type="IN">Version of the received name service package.</param>
 * <param name="byClientBlkDrvType" type="IN">Type of block driver, which has received the name service answer on client side.</param>
 * <param name="dwRequestID" type="IN">The same value that was passed in to the request.</param>
 * <param name="bComplete" type="IN">Is true, if this was the last answer to the request.</param>
 * <result></result>
 */
typedef void (CDECL *PFHANDLENSRESPONSE3) (RTS_RESULT nResult, NODEADDRESS addrNode, NODEINFOPACKED3 *pNodeInfo3, unsigned short wVersion, RTS_UI8 byClientBlkDrvType, RTS_HANDLE dwRequestId, int bComplete);


/**
 * <description>
 *	Retrieve the node information for the node with name pwszName.
 *	The result is returned asynchronously by calling the pfCallback function, as soon as a node answers.
 *  If the node is not unique in the PLC network all nodes with the specified name will answer.
 *  The end of the scan is indicated by calling pfCallback with ERR_TIMEOUT.
 *	In some cases the pfCallback might be called before this function returns. The caller must be prepared
 *	to deal with that situation.
 * </description>
 * <param name="pwszName" type="IN">The name of the node to find</param>
 * <param name="dwRequestId" type="IN">Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback function.</param>
 * <param name="pfCallback" type="IN">The function to be called when retrieving an answer.</param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSResolveName(const RTS_WCHAR * pwszName, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback);
typedef RTS_RESULT (CDECL * PFNSRESOLVENAME) (const RTS_WCHAR * pwszName, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSRESOLVENAME_NOTIMPLEMENTED)
	#define USE_NSResolveName
	#define EXT_NSResolveName
	#define GET_NSResolveName(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSResolveName(p0,p1,p2)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSResolveName  FALSE
	#define EXP_NSResolveName  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSResolveName
	#define EXT_NSResolveName
	#define GET_NSResolveName(fl)  CAL_CMGETAPI( "NSResolveName" ) 
	#define CAL_NSResolveName  NSResolveName
	#define CHK_NSResolveName  TRUE
	#define EXP_NSResolveName  CAL_CMEXPAPI( "NSResolveName" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSResolveName
	#define EXT_NSResolveName
	#define GET_NSResolveName(fl)  CAL_CMGETAPI( "NSResolveName" ) 
	#define CAL_NSResolveName  NSResolveName
	#define CHK_NSResolveName  TRUE
	#define EXP_NSResolveName  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveName", (RTS_UINTPTR)NSResolveName, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSResolveName
	#define EXT_CmpNameServiceClientNSResolveName
	#define GET_CmpNameServiceClientNSResolveName  ERR_OK
	#define CAL_CmpNameServiceClientNSResolveName pICmpNameServiceClient->INSResolveName
	#define CHK_CmpNameServiceClientNSResolveName (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSResolveName  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSResolveName
	#define EXT_NSResolveName
	#define GET_NSResolveName(fl)  CAL_CMGETAPI( "NSResolveName" ) 
	#define CAL_NSResolveName pICmpNameServiceClient->INSResolveName
	#define CHK_NSResolveName (pICmpNameServiceClient != NULL)
	#define EXP_NSResolveName  CAL_CMEXPAPI( "NSResolveName" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSResolveName  PFNSRESOLVENAME pfNSResolveName;
	#define EXT_NSResolveName  extern PFNSRESOLVENAME pfNSResolveName;
	#define GET_NSResolveName(fl)  s_pfCMGetAPI2( "NSResolveName", (RTS_VOID_FCTPTR *)&pfNSResolveName, (fl), 0, 0)
	#define CAL_NSResolveName  pfNSResolveName
	#define CHK_NSResolveName  (pfNSResolveName != NULL)
	#define EXP_NSResolveName  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveName", (RTS_UINTPTR)NSResolveName, 0, 0) 
#endif




/**
 * <description>
 *  Retrieve the node information for the node with name pwszName.
 *  The result is returned asynchronously by calling the pfCallback function, as soon as a node answers.
 *  If the node is not unique in the PLC network all nodes with the specified name will answer. Setting the parameter
 *  bFinishWithFirstNode to TRUE is useful, if the client want to connect to the first answering node without
 *  waiting for the timeout. Typically this is used, if unique node names in the network are assured.
 *  The end of the scan is only indicated by calling pfCallback with ERR_TIMEOUT, if bFinishWithFirstNode was set to FALSE
 *  or if no node has anwered the request.
 *  In some cases the pfCallback might be called before this function returns. The caller must be prepared
 *  to deal with that situation.
 * </description>
 * <param name="pwszName" type="IN">The name of the node to find</param>
 * <param name="dwTimeout" type="IN">Overall timeout in ms for this operation. If 0, the default NAMESERVICESRVKEY_INT_SCAN_TIME is used.</param>
 * <param name="bFinishWithFirstNode" type="IN">If TRUE, pfCallback will be called only once for this request. Further answering nodes are ignored.</param>
 * <param name="dwRequestId" type="IN">Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback3 function.</param>
 * <param name="pfCallback3" type="IN">The function to be called when retrieving an answer.</param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSResolveName3(const RTS_WCHAR * pwszName, RTS_UI32 dwTimeout, RTS_BOOL bFinishWithFirstNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3);
typedef RTS_RESULT (CDECL * PFNSRESOLVENAME3) (const RTS_WCHAR * pwszName, RTS_UI32 dwTimeout, RTS_BOOL bFinishWithFirstNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSRESOLVENAME3_NOTIMPLEMENTED)
	#define USE_NSResolveName3
	#define EXT_NSResolveName3
	#define GET_NSResolveName3(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSResolveName3(p0,p1,p2,p3,p4)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSResolveName3  FALSE
	#define EXP_NSResolveName3  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSResolveName3
	#define EXT_NSResolveName3
	#define GET_NSResolveName3(fl)  CAL_CMGETAPI( "NSResolveName3" ) 
	#define CAL_NSResolveName3  NSResolveName3
	#define CHK_NSResolveName3  TRUE
	#define EXP_NSResolveName3  CAL_CMEXPAPI( "NSResolveName3" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSResolveName3
	#define EXT_NSResolveName3
	#define GET_NSResolveName3(fl)  CAL_CMGETAPI( "NSResolveName3" ) 
	#define CAL_NSResolveName3  NSResolveName3
	#define CHK_NSResolveName3  TRUE
	#define EXP_NSResolveName3  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveName3", (RTS_UINTPTR)NSResolveName3, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSResolveName3
	#define EXT_CmpNameServiceClientNSResolveName3
	#define GET_CmpNameServiceClientNSResolveName3  ERR_OK
	#define CAL_CmpNameServiceClientNSResolveName3 pICmpNameServiceClient->INSResolveName3
	#define CHK_CmpNameServiceClientNSResolveName3 (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSResolveName3  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSResolveName3
	#define EXT_NSResolveName3
	#define GET_NSResolveName3(fl)  CAL_CMGETAPI( "NSResolveName3" ) 
	#define CAL_NSResolveName3 pICmpNameServiceClient->INSResolveName3
	#define CHK_NSResolveName3 (pICmpNameServiceClient != NULL)
	#define EXP_NSResolveName3  CAL_CMEXPAPI( "NSResolveName3" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSResolveName3  PFNSRESOLVENAME3 pfNSResolveName3;
	#define EXT_NSResolveName3  extern PFNSRESOLVENAME3 pfNSResolveName3;
	#define GET_NSResolveName3(fl)  s_pfCMGetAPI2( "NSResolveName3", (RTS_VOID_FCTPTR *)&pfNSResolveName3, (fl), 0, 0)
	#define CAL_NSResolveName3  pfNSResolveName3
	#define CHK_NSResolveName3  (pfNSResolveName3 != NULL)
	#define EXP_NSResolveName3  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveName3", (RTS_UINTPTR)NSResolveName3, 0, 0) 
#endif




/**
 * <description>
 *	Retrieve the node information for the node with the given address.
 *	The result is returned asynchronously by calling the pfCallback function,
 *	as soon as the node answers. pfCallback will be called only once for this request.
 *	In some cases the pfCallback might be called before this function returns. The caller
 *	must be prepared to deal with that situation.
 * </description>
 * <param name="addrNode" type="IN">Address of the node to find.</param>
 * <param name="dwRequestId" type="IN">Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback function.</param>
 * <param name="pfCallback" type="IN">The function to be called when retrieving an answer.</param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSResolveAddress(NODEADDRESS addrNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback);
typedef RTS_RESULT (CDECL * PFNSRESOLVEADDRESS) (NODEADDRESS addrNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSRESOLVEADDRESS_NOTIMPLEMENTED)
	#define USE_NSResolveAddress
	#define EXT_NSResolveAddress
	#define GET_NSResolveAddress(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSResolveAddress(p0,p1,p2)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSResolveAddress  FALSE
	#define EXP_NSResolveAddress  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSResolveAddress
	#define EXT_NSResolveAddress
	#define GET_NSResolveAddress(fl)  CAL_CMGETAPI( "NSResolveAddress" ) 
	#define CAL_NSResolveAddress  NSResolveAddress
	#define CHK_NSResolveAddress  TRUE
	#define EXP_NSResolveAddress  CAL_CMEXPAPI( "NSResolveAddress" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSResolveAddress
	#define EXT_NSResolveAddress
	#define GET_NSResolveAddress(fl)  CAL_CMGETAPI( "NSResolveAddress" ) 
	#define CAL_NSResolveAddress  NSResolveAddress
	#define CHK_NSResolveAddress  TRUE
	#define EXP_NSResolveAddress  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAddress", (RTS_UINTPTR)NSResolveAddress, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSResolveAddress
	#define EXT_CmpNameServiceClientNSResolveAddress
	#define GET_CmpNameServiceClientNSResolveAddress  ERR_OK
	#define CAL_CmpNameServiceClientNSResolveAddress pICmpNameServiceClient->INSResolveAddress
	#define CHK_CmpNameServiceClientNSResolveAddress (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSResolveAddress  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSResolveAddress
	#define EXT_NSResolveAddress
	#define GET_NSResolveAddress(fl)  CAL_CMGETAPI( "NSResolveAddress" ) 
	#define CAL_NSResolveAddress pICmpNameServiceClient->INSResolveAddress
	#define CHK_NSResolveAddress (pICmpNameServiceClient != NULL)
	#define EXP_NSResolveAddress  CAL_CMEXPAPI( "NSResolveAddress" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSResolveAddress  PFNSRESOLVEADDRESS pfNSResolveAddress;
	#define EXT_NSResolveAddress  extern PFNSRESOLVEADDRESS pfNSResolveAddress;
	#define GET_NSResolveAddress(fl)  s_pfCMGetAPI2( "NSResolveAddress", (RTS_VOID_FCTPTR *)&pfNSResolveAddress, (fl), 0, 0)
	#define CAL_NSResolveAddress  pfNSResolveAddress
	#define CHK_NSResolveAddress  (pfNSResolveAddress != NULL)
	#define EXP_NSResolveAddress  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAddress", (RTS_UINTPTR)NSResolveAddress, 0, 0) 
#endif




/**
 * <description>
 *	Retrieve the node information for the node with the given address.
 *	The result is returned asynchronously by calling the pfCallback2 function,
 *	as soon as the node answers. pfCallback2 will be called only once for this request.
 *	In some cases the pfCallback2 might be called before this function returns. The caller
 *	must be prepared to deal with that situation.
 * </description>
 * <param name="addrNode" type="IN">Address of the node to find.</param>
 * <param name="dwRequestId" type="IN">Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback2 function.</param>
 * <param name="pfCallback2" type="IN">The function to be called when retrieving an answer.</param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSResolveAddress2(NODEADDRESS addrNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2);
typedef RTS_RESULT (CDECL * PFNSRESOLVEADDRESS2) (NODEADDRESS addrNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSRESOLVEADDRESS2_NOTIMPLEMENTED)
	#define USE_NSResolveAddress2
	#define EXT_NSResolveAddress2
	#define GET_NSResolveAddress2(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSResolveAddress2(p0,p1,p2)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSResolveAddress2  FALSE
	#define EXP_NSResolveAddress2  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSResolveAddress2
	#define EXT_NSResolveAddress2
	#define GET_NSResolveAddress2(fl)  CAL_CMGETAPI( "NSResolveAddress2" ) 
	#define CAL_NSResolveAddress2  NSResolveAddress2
	#define CHK_NSResolveAddress2  TRUE
	#define EXP_NSResolveAddress2  CAL_CMEXPAPI( "NSResolveAddress2" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSResolveAddress2
	#define EXT_NSResolveAddress2
	#define GET_NSResolveAddress2(fl)  CAL_CMGETAPI( "NSResolveAddress2" ) 
	#define CAL_NSResolveAddress2  NSResolveAddress2
	#define CHK_NSResolveAddress2  TRUE
	#define EXP_NSResolveAddress2  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAddress2", (RTS_UINTPTR)NSResolveAddress2, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSResolveAddress2
	#define EXT_CmpNameServiceClientNSResolveAddress2
	#define GET_CmpNameServiceClientNSResolveAddress2  ERR_OK
	#define CAL_CmpNameServiceClientNSResolveAddress2 pICmpNameServiceClient->INSResolveAddress2
	#define CHK_CmpNameServiceClientNSResolveAddress2 (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSResolveAddress2  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSResolveAddress2
	#define EXT_NSResolveAddress2
	#define GET_NSResolveAddress2(fl)  CAL_CMGETAPI( "NSResolveAddress2" ) 
	#define CAL_NSResolveAddress2 pICmpNameServiceClient->INSResolveAddress2
	#define CHK_NSResolveAddress2 (pICmpNameServiceClient != NULL)
	#define EXP_NSResolveAddress2  CAL_CMEXPAPI( "NSResolveAddress2" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSResolveAddress2  PFNSRESOLVEADDRESS2 pfNSResolveAddress2;
	#define EXT_NSResolveAddress2  extern PFNSRESOLVEADDRESS2 pfNSResolveAddress2;
	#define GET_NSResolveAddress2(fl)  s_pfCMGetAPI2( "NSResolveAddress2", (RTS_VOID_FCTPTR *)&pfNSResolveAddress2, (fl), 0, 0)
	#define CAL_NSResolveAddress2  pfNSResolveAddress2
	#define CHK_NSResolveAddress2  (pfNSResolveAddress2 != NULL)
	#define EXP_NSResolveAddress2  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAddress2", (RTS_UINTPTR)NSResolveAddress2, 0, 0) 
#endif




/**
 * <description>
 *  Retrieve the node information for the node with the given address.
 *  The result is returned asynchronously by calling the pfCallback3 function,
 *  as soon as the node answers. pfCallback3 will be called only once for this request.
 *  In some cases the pfCallback3 might be called before this function returns. The caller
 *  must be prepared to deal with that situation.
 * </description>
 * <param name="addrNode" type="IN">Address of the node to find.</param>
 * <param name="dwTimeout" type="IN">Overall timeout in ms for this operation. If 0, the default NAMESERVICESRVKEY_INT_SCAN_TIME is used.</param>
 * <param name="dwRequestId" type="IN">Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback3 function.</param>
 * <param name="pfCallback3" type="IN">The function to be called when retrieving an answer.</param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSResolveAddress3(NODEADDRESS addrNode, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3);
typedef RTS_RESULT (CDECL * PFNSRESOLVEADDRESS3) (NODEADDRESS addrNode, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSRESOLVEADDRESS3_NOTIMPLEMENTED)
	#define USE_NSResolveAddress3
	#define EXT_NSResolveAddress3
	#define GET_NSResolveAddress3(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSResolveAddress3(p0,p1,p2,p3)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSResolveAddress3  FALSE
	#define EXP_NSResolveAddress3  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSResolveAddress3
	#define EXT_NSResolveAddress3
	#define GET_NSResolveAddress3(fl)  CAL_CMGETAPI( "NSResolveAddress3" ) 
	#define CAL_NSResolveAddress3  NSResolveAddress3
	#define CHK_NSResolveAddress3  TRUE
	#define EXP_NSResolveAddress3  CAL_CMEXPAPI( "NSResolveAddress3" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSResolveAddress3
	#define EXT_NSResolveAddress3
	#define GET_NSResolveAddress3(fl)  CAL_CMGETAPI( "NSResolveAddress3" ) 
	#define CAL_NSResolveAddress3  NSResolveAddress3
	#define CHK_NSResolveAddress3  TRUE
	#define EXP_NSResolveAddress3  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAddress3", (RTS_UINTPTR)NSResolveAddress3, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSResolveAddress3
	#define EXT_CmpNameServiceClientNSResolveAddress3
	#define GET_CmpNameServiceClientNSResolveAddress3  ERR_OK
	#define CAL_CmpNameServiceClientNSResolveAddress3 pICmpNameServiceClient->INSResolveAddress3
	#define CHK_CmpNameServiceClientNSResolveAddress3 (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSResolveAddress3  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSResolveAddress3
	#define EXT_NSResolveAddress3
	#define GET_NSResolveAddress3(fl)  CAL_CMGETAPI( "NSResolveAddress3" ) 
	#define CAL_NSResolveAddress3 pICmpNameServiceClient->INSResolveAddress3
	#define CHK_NSResolveAddress3 (pICmpNameServiceClient != NULL)
	#define EXP_NSResolveAddress3  CAL_CMEXPAPI( "NSResolveAddress3" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSResolveAddress3  PFNSRESOLVEADDRESS3 pfNSResolveAddress3;
	#define EXT_NSResolveAddress3  extern PFNSRESOLVEADDRESS3 pfNSResolveAddress3;
	#define GET_NSResolveAddress3(fl)  s_pfCMGetAPI2( "NSResolveAddress3", (RTS_VOID_FCTPTR *)&pfNSResolveAddress3, (fl), 0, 0)
	#define CAL_NSResolveAddress3  pfNSResolveAddress3
	#define CHK_NSResolveAddress3  (pfNSResolveAddress3 != NULL)
	#define EXP_NSResolveAddress3  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAddress3", (RTS_UINTPTR)NSResolveAddress3, 0, 0) 
#endif




/**
 * <description>
 *	Retrieve the node information for the node with the given block driver address.
 *  This is specified by the block driver type and the address in the local network (e. g. ipaddress and port).
 *  If RTS_BLK_DRV_TYPE_NONE is passed, the function returns the address of the own runtime system.
 *  In this special use case the node info may not contain a valid node info.
 *	The result is returned asynchronously by calling the pfCallback2 function,
 *	as soon as the node answers. pfCallback2 will be called only once for this request.
 *	In some cases the pfCallback2 might be called before this function returns. The caller
 *	must be prepared to deal with that situation.
 * </description>
 * <param name="byBlkDrvType" type="IN">
 *  The type of the block driver, which should should resolve the address. If set to RTS_BLK_DRV_TYPE_NONE, 
 *  the address of the own runtime system is returned.
 * </param>
 * <param name="byFlags" type="IN">
 *  For future use, must be 0.
 * </param>
 * <param name="byAddrBitLength" type="IN">
 *  Bit length of the network address. Must match with the block driver configuration. 
 *  Should be 0, if RTS_BLK_DRV_TYPE_NONE is used to get the own node info.
 * </param>
 * <param name="pNetworkAddr" type="IN">
 *  Local network address of the node to find.
 *  Should be NULL, if RTS_BLK_DRV_TYPE_NONE is used to get the own node info.
 * </param>
 * <param name="dwRequestId" type="IN">
 *  Identifies the request. Returned again by the pfCallback2 function. Parallel running requests should have a unique id.
 * </param>
 * <param name="pfCallback2" type="IN">
 *  The function to be called when retrieving an answer.
 * </param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSResolveBlkDrvAddress2(RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, NETWORKADDRESS *pNetworkAddr, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2);
typedef RTS_RESULT (CDECL * PFNSRESOLVEBLKDRVADDRESS2) (RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, NETWORKADDRESS *pNetworkAddr, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSRESOLVEBLKDRVADDRESS2_NOTIMPLEMENTED)
	#define USE_NSResolveBlkDrvAddress2
	#define EXT_NSResolveBlkDrvAddress2
	#define GET_NSResolveBlkDrvAddress2(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSResolveBlkDrvAddress2(p0,p1,p2,p3,p4,p5)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSResolveBlkDrvAddress2  FALSE
	#define EXP_NSResolveBlkDrvAddress2  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSResolveBlkDrvAddress2
	#define EXT_NSResolveBlkDrvAddress2
	#define GET_NSResolveBlkDrvAddress2(fl)  CAL_CMGETAPI( "NSResolveBlkDrvAddress2" ) 
	#define CAL_NSResolveBlkDrvAddress2  NSResolveBlkDrvAddress2
	#define CHK_NSResolveBlkDrvAddress2  TRUE
	#define EXP_NSResolveBlkDrvAddress2  CAL_CMEXPAPI( "NSResolveBlkDrvAddress2" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSResolveBlkDrvAddress2
	#define EXT_NSResolveBlkDrvAddress2
	#define GET_NSResolveBlkDrvAddress2(fl)  CAL_CMGETAPI( "NSResolveBlkDrvAddress2" ) 
	#define CAL_NSResolveBlkDrvAddress2  NSResolveBlkDrvAddress2
	#define CHK_NSResolveBlkDrvAddress2  TRUE
	#define EXP_NSResolveBlkDrvAddress2  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveBlkDrvAddress2", (RTS_UINTPTR)NSResolveBlkDrvAddress2, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSResolveBlkDrvAddress2
	#define EXT_CmpNameServiceClientNSResolveBlkDrvAddress2
	#define GET_CmpNameServiceClientNSResolveBlkDrvAddress2  ERR_OK
	#define CAL_CmpNameServiceClientNSResolveBlkDrvAddress2 pICmpNameServiceClient->INSResolveBlkDrvAddress2
	#define CHK_CmpNameServiceClientNSResolveBlkDrvAddress2 (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSResolveBlkDrvAddress2  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSResolveBlkDrvAddress2
	#define EXT_NSResolveBlkDrvAddress2
	#define GET_NSResolveBlkDrvAddress2(fl)  CAL_CMGETAPI( "NSResolveBlkDrvAddress2" ) 
	#define CAL_NSResolveBlkDrvAddress2 pICmpNameServiceClient->INSResolveBlkDrvAddress2
	#define CHK_NSResolveBlkDrvAddress2 (pICmpNameServiceClient != NULL)
	#define EXP_NSResolveBlkDrvAddress2  CAL_CMEXPAPI( "NSResolveBlkDrvAddress2" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSResolveBlkDrvAddress2  PFNSRESOLVEBLKDRVADDRESS2 pfNSResolveBlkDrvAddress2;
	#define EXT_NSResolveBlkDrvAddress2  extern PFNSRESOLVEBLKDRVADDRESS2 pfNSResolveBlkDrvAddress2;
	#define GET_NSResolveBlkDrvAddress2(fl)  s_pfCMGetAPI2( "NSResolveBlkDrvAddress2", (RTS_VOID_FCTPTR *)&pfNSResolveBlkDrvAddress2, (fl), 0, 0)
	#define CAL_NSResolveBlkDrvAddress2  pfNSResolveBlkDrvAddress2
	#define CHK_NSResolveBlkDrvAddress2  (pfNSResolveBlkDrvAddress2 != NULL)
	#define EXP_NSResolveBlkDrvAddress2  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveBlkDrvAddress2", (RTS_UINTPTR)NSResolveBlkDrvAddress2, 0, 0) 
#endif




/**
 * <description>
 *  Retrieve the node information for the node with the given block driver address.
 *  This is specified by the block driver type and the address in the local network (e. g. ipaddress and port).
 *  If RTS_BLK_DRV_TYPE_NONE is passed, the function returns the address of the own runtime system.
 *  In this special use case the node info may not contain a valid node info.
 *  The result is returned asynchronously by calling the pfCallback3 function,
 *  as soon as the node answers. pfCallback3 will be called only once for this request.
 *  In some cases the pfCallback3 might be called before this function returns. The caller
 *  must be prepared to deal with that situation.
 * </description>
 * <param name="byBlkDrvType" type="IN">
 *  The type of the block driver, which should should resolve the address. If set to RTS_BLK_DRV_TYPE_NONE,
 *  the address of the own runtime system is returned.
 * </param>
 * <param name="byFlags" type="IN">
 *  For future use, must be 0.
 * </param>
 * <param name="byAddrBitLength" type="IN">
 *  Bit length of the network address. Must match with the block driver configuration.
 *  Should be 0, if RTS_BLK_DRV_TYPE_NONE is used to get the own node info.
 * </param>
 * <param name="pNetworkAddr" type="IN">
 *  Local network address of the node to find.
 *  Should be NULL, if RTS_BLK_DRV_TYPE_NONE is used to get the own node info.
 * </param>
 * <param name="dwTimeout" type="IN">
 *  Overall timeout in ms for this operation. If 0, the default NAMESERVICESRVKEY_INT_SCAN_TIME is used.
 * </param>
 * <param name="dwRequestId" type="IN">
 *  Identifies the request. Returned again by the pfCallback3 function. Parallel running requests should have a unique id.
 * </param>
 * <param name="pfCallback3" type="IN">
 *  The function to be called when retrieving an answer.
 * </param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSResolveBlkDrvAddress3(RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, NETWORKADDRESS *pNetworkAddr, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3);
typedef RTS_RESULT (CDECL * PFNSRESOLVEBLKDRVADDRESS3) (RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, NETWORKADDRESS *pNetworkAddr, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSRESOLVEBLKDRVADDRESS3_NOTIMPLEMENTED)
	#define USE_NSResolveBlkDrvAddress3
	#define EXT_NSResolveBlkDrvAddress3
	#define GET_NSResolveBlkDrvAddress3(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSResolveBlkDrvAddress3(p0,p1,p2,p3,p4,p5,p6)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSResolveBlkDrvAddress3  FALSE
	#define EXP_NSResolveBlkDrvAddress3  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSResolveBlkDrvAddress3
	#define EXT_NSResolveBlkDrvAddress3
	#define GET_NSResolveBlkDrvAddress3(fl)  CAL_CMGETAPI( "NSResolveBlkDrvAddress3" ) 
	#define CAL_NSResolveBlkDrvAddress3  NSResolveBlkDrvAddress3
	#define CHK_NSResolveBlkDrvAddress3  TRUE
	#define EXP_NSResolveBlkDrvAddress3  CAL_CMEXPAPI( "NSResolveBlkDrvAddress3" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSResolveBlkDrvAddress3
	#define EXT_NSResolveBlkDrvAddress3
	#define GET_NSResolveBlkDrvAddress3(fl)  CAL_CMGETAPI( "NSResolveBlkDrvAddress3" ) 
	#define CAL_NSResolveBlkDrvAddress3  NSResolveBlkDrvAddress3
	#define CHK_NSResolveBlkDrvAddress3  TRUE
	#define EXP_NSResolveBlkDrvAddress3  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveBlkDrvAddress3", (RTS_UINTPTR)NSResolveBlkDrvAddress3, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSResolveBlkDrvAddress3
	#define EXT_CmpNameServiceClientNSResolveBlkDrvAddress3
	#define GET_CmpNameServiceClientNSResolveBlkDrvAddress3  ERR_OK
	#define CAL_CmpNameServiceClientNSResolveBlkDrvAddress3 pICmpNameServiceClient->INSResolveBlkDrvAddress3
	#define CHK_CmpNameServiceClientNSResolveBlkDrvAddress3 (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSResolveBlkDrvAddress3  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSResolveBlkDrvAddress3
	#define EXT_NSResolveBlkDrvAddress3
	#define GET_NSResolveBlkDrvAddress3(fl)  CAL_CMGETAPI( "NSResolveBlkDrvAddress3" ) 
	#define CAL_NSResolveBlkDrvAddress3 pICmpNameServiceClient->INSResolveBlkDrvAddress3
	#define CHK_NSResolveBlkDrvAddress3 (pICmpNameServiceClient != NULL)
	#define EXP_NSResolveBlkDrvAddress3  CAL_CMEXPAPI( "NSResolveBlkDrvAddress3" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSResolveBlkDrvAddress3  PFNSRESOLVEBLKDRVADDRESS3 pfNSResolveBlkDrvAddress3;
	#define EXT_NSResolveBlkDrvAddress3  extern PFNSRESOLVEBLKDRVADDRESS3 pfNSResolveBlkDrvAddress3;
	#define GET_NSResolveBlkDrvAddress3(fl)  s_pfCMGetAPI2( "NSResolveBlkDrvAddress3", (RTS_VOID_FCTPTR *)&pfNSResolveBlkDrvAddress3, (fl), 0, 0)
	#define CAL_NSResolveBlkDrvAddress3  pfNSResolveBlkDrvAddress3
	#define CHK_NSResolveBlkDrvAddress3  (pfNSResolveBlkDrvAddress3 != NULL)
	#define EXP_NSResolveBlkDrvAddress3  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveBlkDrvAddress3", (RTS_UINTPTR)NSResolveBlkDrvAddress3, 0, 0) 
#endif




/**
 * <description>
 *	Retrieve all nodes in the network.
 *	The result is returned asynchronously by calling the pfCallback function
 *	once for every answering node. That means pfCallback will be called an unknown
 *	number of times. bComplete will not resolve to TRUE until nResult is set to ERR_TIMEOUT.
 *	Thus ERR_TIMEOUT is an expected result for this request.
 *	In some cases the pfCallback might be called before this function
 *	returns. The caller must be prepared to deal with that situation.
 * </description>
 * <param name="dwRequestId" type="IN">Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback function.</param>
 * <param name="pfCallback" type="IN">The function to be called when retrieving an answer.</param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSResolveAll(RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback);
typedef RTS_RESULT (CDECL * PFNSRESOLVEALL) (RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSRESOLVEALL_NOTIMPLEMENTED)
	#define USE_NSResolveAll
	#define EXT_NSResolveAll
	#define GET_NSResolveAll(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSResolveAll(p0,p1)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSResolveAll  FALSE
	#define EXP_NSResolveAll  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSResolveAll
	#define EXT_NSResolveAll
	#define GET_NSResolveAll(fl)  CAL_CMGETAPI( "NSResolveAll" ) 
	#define CAL_NSResolveAll  NSResolveAll
	#define CHK_NSResolveAll  TRUE
	#define EXP_NSResolveAll  CAL_CMEXPAPI( "NSResolveAll" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSResolveAll
	#define EXT_NSResolveAll
	#define GET_NSResolveAll(fl)  CAL_CMGETAPI( "NSResolveAll" ) 
	#define CAL_NSResolveAll  NSResolveAll
	#define CHK_NSResolveAll  TRUE
	#define EXP_NSResolveAll  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAll", (RTS_UINTPTR)NSResolveAll, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSResolveAll
	#define EXT_CmpNameServiceClientNSResolveAll
	#define GET_CmpNameServiceClientNSResolveAll  ERR_OK
	#define CAL_CmpNameServiceClientNSResolveAll pICmpNameServiceClient->INSResolveAll
	#define CHK_CmpNameServiceClientNSResolveAll (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSResolveAll  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSResolveAll
	#define EXT_NSResolveAll
	#define GET_NSResolveAll(fl)  CAL_CMGETAPI( "NSResolveAll" ) 
	#define CAL_NSResolveAll pICmpNameServiceClient->INSResolveAll
	#define CHK_NSResolveAll (pICmpNameServiceClient != NULL)
	#define EXP_NSResolveAll  CAL_CMEXPAPI( "NSResolveAll" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSResolveAll  PFNSRESOLVEALL pfNSResolveAll;
	#define EXT_NSResolveAll  extern PFNSRESOLVEALL pfNSResolveAll;
	#define GET_NSResolveAll(fl)  s_pfCMGetAPI2( "NSResolveAll", (RTS_VOID_FCTPTR *)&pfNSResolveAll, (fl), 0, 0)
	#define CAL_NSResolveAll  pfNSResolveAll
	#define CHK_NSResolveAll  (pfNSResolveAll != NULL)
	#define EXP_NSResolveAll  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAll", (RTS_UINTPTR)NSResolveAll, 0, 0) 
#endif




/**
 * <description>
 *	Retrieve all nodes in the network.
 *	The result is returned asynchronously by calling the pfCallback2 function
 *	once for every answering node. That means pfCallback2 will be called an unknown
 *	number of times. bComplete will not resolve to TRUE until nResult is set to ERR_TIMEOUT.
 *	Thus ERR_TIMEOUT is an expected result for this request.
 *	In some cases the pfCallback2 might be called before this function returns. The caller must
 *	be prepared to deal with that situation.
 * </description>
 * <param name="dwRequestId" type="IN">Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback2 function.</param>
 * <param name="pfCallback2" type="IN">The function to be called when retrieving an answer.</param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSResolveAll2(RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2);
typedef RTS_RESULT (CDECL * PFNSRESOLVEALL2) (RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSRESOLVEALL2_NOTIMPLEMENTED)
	#define USE_NSResolveAll2
	#define EXT_NSResolveAll2
	#define GET_NSResolveAll2(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSResolveAll2(p0,p1)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSResolveAll2  FALSE
	#define EXP_NSResolveAll2  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSResolveAll2
	#define EXT_NSResolveAll2
	#define GET_NSResolveAll2(fl)  CAL_CMGETAPI( "NSResolveAll2" ) 
	#define CAL_NSResolveAll2  NSResolveAll2
	#define CHK_NSResolveAll2  TRUE
	#define EXP_NSResolveAll2  CAL_CMEXPAPI( "NSResolveAll2" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSResolveAll2
	#define EXT_NSResolveAll2
	#define GET_NSResolveAll2(fl)  CAL_CMGETAPI( "NSResolveAll2" ) 
	#define CAL_NSResolveAll2  NSResolveAll2
	#define CHK_NSResolveAll2  TRUE
	#define EXP_NSResolveAll2  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAll2", (RTS_UINTPTR)NSResolveAll2, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSResolveAll2
	#define EXT_CmpNameServiceClientNSResolveAll2
	#define GET_CmpNameServiceClientNSResolveAll2  ERR_OK
	#define CAL_CmpNameServiceClientNSResolveAll2 pICmpNameServiceClient->INSResolveAll2
	#define CHK_CmpNameServiceClientNSResolveAll2 (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSResolveAll2  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSResolveAll2
	#define EXT_NSResolveAll2
	#define GET_NSResolveAll2(fl)  CAL_CMGETAPI( "NSResolveAll2" ) 
	#define CAL_NSResolveAll2 pICmpNameServiceClient->INSResolveAll2
	#define CHK_NSResolveAll2 (pICmpNameServiceClient != NULL)
	#define EXP_NSResolveAll2  CAL_CMEXPAPI( "NSResolveAll2" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSResolveAll2  PFNSRESOLVEALL2 pfNSResolveAll2;
	#define EXT_NSResolveAll2  extern PFNSRESOLVEALL2 pfNSResolveAll2;
	#define GET_NSResolveAll2(fl)  s_pfCMGetAPI2( "NSResolveAll2", (RTS_VOID_FCTPTR *)&pfNSResolveAll2, (fl), 0, 0)
	#define CAL_NSResolveAll2  pfNSResolveAll2
	#define CHK_NSResolveAll2  (pfNSResolveAll2 != NULL)
	#define EXP_NSResolveAll2  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAll2", (RTS_UINTPTR)NSResolveAll2, 0, 0) 
#endif




/**
 * <description>
 *  Retrieve all nodes in the network.
 *  The result is returned asynchronously by calling the pfCallback3 function
 *  once for every answering node. That means pfCallback3 will be called an unknown
 *  number of times. bComplete will not resolve to TRUE until nResult is set to ERR_TIMEOUT.
 *  Thus ERR_TIMEOUT is an expected result for this request.
 *  In some cases the pfCallback3 might be called before this function returns. The caller must
 *  be prepared to deal with that situation.
 * </description>
 * <param name="dwTimeout" type="IN">Overall timeout in ms for this operation. If 0, the default NAMESERVICESRVKEY_INT_SCAN_TIME is used.</param>
 * <param name="dwRequestId" type="IN">Identifies the request. Parallel running requests should have a unique id. Returned again by the pfCallback3 function.</param>
 * <param name="pfCallback3" type="IN">The function to be called when retrieving an answer.</param>
 * <result>error code</result>
 */
RTS_RESULT CDECL NSResolveAll3(RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3);
typedef RTS_RESULT (CDECL * PFNSRESOLVEALL3) (RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSRESOLVEALL3_NOTIMPLEMENTED)
	#define USE_NSResolveAll3
	#define EXT_NSResolveAll3
	#define GET_NSResolveAll3(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSResolveAll3(p0,p1,p2)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSResolveAll3  FALSE
	#define EXP_NSResolveAll3  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSResolveAll3
	#define EXT_NSResolveAll3
	#define GET_NSResolveAll3(fl)  CAL_CMGETAPI( "NSResolveAll3" ) 
	#define CAL_NSResolveAll3  NSResolveAll3
	#define CHK_NSResolveAll3  TRUE
	#define EXP_NSResolveAll3  CAL_CMEXPAPI( "NSResolveAll3" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSResolveAll3
	#define EXT_NSResolveAll3
	#define GET_NSResolveAll3(fl)  CAL_CMGETAPI( "NSResolveAll3" ) 
	#define CAL_NSResolveAll3  NSResolveAll3
	#define CHK_NSResolveAll3  TRUE
	#define EXP_NSResolveAll3  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAll3", (RTS_UINTPTR)NSResolveAll3, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSResolveAll3
	#define EXT_CmpNameServiceClientNSResolveAll3
	#define GET_CmpNameServiceClientNSResolveAll3  ERR_OK
	#define CAL_CmpNameServiceClientNSResolveAll3 pICmpNameServiceClient->INSResolveAll3
	#define CHK_CmpNameServiceClientNSResolveAll3 (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSResolveAll3  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSResolveAll3
	#define EXT_NSResolveAll3
	#define GET_NSResolveAll3(fl)  CAL_CMGETAPI( "NSResolveAll3" ) 
	#define CAL_NSResolveAll3 pICmpNameServiceClient->INSResolveAll3
	#define CHK_NSResolveAll3 (pICmpNameServiceClient != NULL)
	#define EXP_NSResolveAll3  CAL_CMEXPAPI( "NSResolveAll3" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSResolveAll3  PFNSRESOLVEALL3 pfNSResolveAll3;
	#define EXT_NSResolveAll3  extern PFNSRESOLVEALL3 pfNSResolveAll3;
	#define GET_NSResolveAll3(fl)  s_pfCMGetAPI2( "NSResolveAll3", (RTS_VOID_FCTPTR *)&pfNSResolveAll3, (fl), 0, 0)
	#define CAL_NSResolveAll3  pfNSResolveAll3
	#define CHK_NSResolveAll3  (pfNSResolveAll3 != NULL)
	#define EXP_NSResolveAll3  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSResolveAll3", (RTS_UINTPTR)NSResolveAll3, 0, 0) 
#endif




/**
* <description>
*  With this function the remaining timeout of all NSResolve... functions can be adjusted. The typical use case is to set the
*  timeout to 0, as soon as the expected node has answered. Beside the new timeout the running NSResolve... function is not 
*  affected in its behavior.
* </description>
* <param name="dwRemainingTimeout" type="IN">Remaining timeout in ms for already running resolve request.</param>
* <param name="dwRequestId" type="IN">Id of the request, whose remaining resolve time should be set.</param>
* <result>error code</result>
*/
RTS_RESULT CDECL NSAdjustResolveTimeout(RTS_UI32 dwRemainingTimeout, RTS_HANDLE dwRequestId);
typedef RTS_RESULT (CDECL * PFNSADJUSTRESOLVETIMEOUT) (RTS_UI32 dwRemainingTimeout, RTS_HANDLE dwRequestId);
#if defined(CMPNAMESERVICECLIENT_NOTIMPLEMENTED) || defined(NSADJUSTRESOLVETIMEOUT_NOTIMPLEMENTED)
	#define USE_NSAdjustResolveTimeout
	#define EXT_NSAdjustResolveTimeout
	#define GET_NSAdjustResolveTimeout(fl)  ERR_NOTIMPLEMENTED
	#define CAL_NSAdjustResolveTimeout(p0,p1)  (RTS_RESULT)ERR_NOTIMPLEMENTED
	#define CHK_NSAdjustResolveTimeout  FALSE
	#define EXP_NSAdjustResolveTimeout  ERR_OK
#elif defined(STATIC_LINK)
	#define USE_NSAdjustResolveTimeout
	#define EXT_NSAdjustResolveTimeout
	#define GET_NSAdjustResolveTimeout(fl)  CAL_CMGETAPI( "NSAdjustResolveTimeout" ) 
	#define CAL_NSAdjustResolveTimeout  NSAdjustResolveTimeout
	#define CHK_NSAdjustResolveTimeout  TRUE
	#define EXP_NSAdjustResolveTimeout  CAL_CMEXPAPI( "NSAdjustResolveTimeout" ) 
#elif defined(MIXED_LINK) && !defined(CMPNAMESERVICECLIENT_EXTERNAL)
	#define USE_NSAdjustResolveTimeout
	#define EXT_NSAdjustResolveTimeout
	#define GET_NSAdjustResolveTimeout(fl)  CAL_CMGETAPI( "NSAdjustResolveTimeout" ) 
	#define CAL_NSAdjustResolveTimeout  NSAdjustResolveTimeout
	#define CHK_NSAdjustResolveTimeout  TRUE
	#define EXP_NSAdjustResolveTimeout  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSAdjustResolveTimeout", (RTS_UINTPTR)NSAdjustResolveTimeout, 0, 0) 
#elif defined(CPLUSPLUS_ONLY)
	#define USE_CmpNameServiceClientNSAdjustResolveTimeout
	#define EXT_CmpNameServiceClientNSAdjustResolveTimeout
	#define GET_CmpNameServiceClientNSAdjustResolveTimeout  ERR_OK
	#define CAL_CmpNameServiceClientNSAdjustResolveTimeout pICmpNameServiceClient->INSAdjustResolveTimeout
	#define CHK_CmpNameServiceClientNSAdjustResolveTimeout (pICmpNameServiceClient != NULL)
	#define EXP_CmpNameServiceClientNSAdjustResolveTimeout  ERR_OK
#elif defined(CPLUSPLUS)
	#define USE_NSAdjustResolveTimeout
	#define EXT_NSAdjustResolveTimeout
	#define GET_NSAdjustResolveTimeout(fl)  CAL_CMGETAPI( "NSAdjustResolveTimeout" ) 
	#define CAL_NSAdjustResolveTimeout pICmpNameServiceClient->INSAdjustResolveTimeout
	#define CHK_NSAdjustResolveTimeout (pICmpNameServiceClient != NULL)
	#define EXP_NSAdjustResolveTimeout  CAL_CMEXPAPI( "NSAdjustResolveTimeout" ) 
#else /* DYNAMIC_LINK */
	#define USE_NSAdjustResolveTimeout  PFNSADJUSTRESOLVETIMEOUT pfNSAdjustResolveTimeout;
	#define EXT_NSAdjustResolveTimeout  extern PFNSADJUSTRESOLVETIMEOUT pfNSAdjustResolveTimeout;
	#define GET_NSAdjustResolveTimeout(fl)  s_pfCMGetAPI2( "NSAdjustResolveTimeout", (RTS_VOID_FCTPTR *)&pfNSAdjustResolveTimeout, (fl), 0, 0)
	#define CAL_NSAdjustResolveTimeout  pfNSAdjustResolveTimeout
	#define CHK_NSAdjustResolveTimeout  (pfNSAdjustResolveTimeout != NULL)
	#define EXP_NSAdjustResolveTimeout  s_pfCMRegisterAPI( (const CMP_EXT_FUNCTION_REF*)"NSAdjustResolveTimeout", (RTS_UINTPTR)NSAdjustResolveTimeout, 0, 0) 
#endif




#ifdef __cplusplus
}
#endif



typedef struct
{
	IBase_C *pBase;
	PFNSCLIENTHANDLEDATA INSClientHandleData;
 	PFNSRESOLVENAME INSResolveName;
 	PFNSRESOLVENAME3 INSResolveName3;
 	PFNSRESOLVEADDRESS INSResolveAddress;
 	PFNSRESOLVEADDRESS2 INSResolveAddress2;
 	PFNSRESOLVEADDRESS3 INSResolveAddress3;
 	PFNSRESOLVEBLKDRVADDRESS2 INSResolveBlkDrvAddress2;
 	PFNSRESOLVEBLKDRVADDRESS3 INSResolveBlkDrvAddress3;
 	PFNSRESOLVEALL INSResolveAll;
 	PFNSRESOLVEALL2 INSResolveAll2;
 	PFNSRESOLVEALL3 INSResolveAll3;
 	PFNSADJUSTRESOLVETIMEOUT INSAdjustResolveTimeout;
 } ICmpNameServiceClient_C;

#ifdef CPLUSPLUS
class ICmpNameServiceClient : public IBase
{
	public:
		virtual RTS_RESULT CDECL INSClientHandleData(RTS_HANDLE hRouter, RTS_HANDLE hNetworkInterface, RTS_UI8 byServiceId, RTS_UI8 byMessageId, PEERADDRESS addrSender, PEERADDRESS addrReceiver, PROTOCOL_DATA_UNIT pduData, RTS_RESULT nRouterError) =0;
		virtual RTS_RESULT CDECL INSResolveName(const RTS_WCHAR * pwszName, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback) =0;
		virtual RTS_RESULT CDECL INSResolveName3(const RTS_WCHAR * pwszName, RTS_UI32 dwTimeout, RTS_BOOL bFinishWithFirstNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3) =0;
		virtual RTS_RESULT CDECL INSResolveAddress(NODEADDRESS addrNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback) =0;
		virtual RTS_RESULT CDECL INSResolveAddress2(NODEADDRESS addrNode, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2) =0;
		virtual RTS_RESULT CDECL INSResolveAddress3(NODEADDRESS addrNode, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3) =0;
		virtual RTS_RESULT CDECL INSResolveBlkDrvAddress2(RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, NETWORKADDRESS *pNetworkAddr, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2) =0;
		virtual RTS_RESULT CDECL INSResolveBlkDrvAddress3(RTS_UI8 byBlkDrvType, RTS_UI8 byFlags, RTS_UI8 byAddrBitLength, NETWORKADDRESS *pNetworkAddr, RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3) =0;
		virtual RTS_RESULT CDECL INSResolveAll(RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE pfCallback) =0;
		virtual RTS_RESULT CDECL INSResolveAll2(RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE2 pfCallback2) =0;
		virtual RTS_RESULT CDECL INSResolveAll3(RTS_UI32 dwTimeout, RTS_HANDLE dwRequestId, PFHANDLENSRESPONSE3 pfCallback3) =0;
		virtual RTS_RESULT CDECL INSAdjustResolveTimeout(RTS_UI32 dwRemainingTimeout, RTS_HANDLE dwRequestId) =0;
};
	#ifndef ITF_CmpNameServiceClient
		#define ITF_CmpNameServiceClient static ICmpNameServiceClient *pICmpNameServiceClient = NULL;
	#endif
	#define EXTITF_CmpNameServiceClient
#else	/*CPLUSPLUS*/
	typedef ICmpNameServiceClient_C		ICmpNameServiceClient;
	#ifndef ITF_CmpNameServiceClient
		#define ITF_CmpNameServiceClient
	#endif
	#define EXTITF_CmpNameServiceClient
#endif

#ifdef CPLUSPLUS_ONLY
  #undef CPLUSPLUS_ONLY
#endif

#endif /*_CMPNAMESERVICECLIENTITF_H_*/
